<h1>Билет #1</h1>

![image](https://user-images.githubusercontent.com/90152615/175813032-64cb7829-8a4f-44e6-8f8b-a681040ec903.png)



<h2>История определения тестирования. Что под ним понимали в разное время?</h2>
Первые программные системы разрабатывались в рамках программ научных исследований или программ для нужд министерств обороны. Тестирование таких продуктов проводилось строго формализованно с записью всех тестовых процедур, тестовых данных, полученных результатов. Тестирование выделялось в отдельный процесс, который начинался после завершения кодирования, но при этом, как правило, выполнялось тем же персоналом.

В 1960-х много внимания уделялось «исчерпывающему» тестированию, которое должно проводиться с использованием всех путей в коде или всех возможных входных данных. Было отмечено, что в этих условиях полное тестирование программного обеспечения невозможно, потому что, во-первых, количество возможных входных данных очень велико, во-вторых, существует множество путей, в-третьих, сложно найти проблемы в архитектуре и спецификациях. По этим причинам «исчерпывающее» тестирование было отклонено и признано теоретически невозможным.

В начале 1970-х годов тестирование программного обеспечения обозначалось как «процесс, направленный на демонстрацию корректности продукта» или как «деятельность по подтверждению правильности работы программного обеспечения». В зарождавшейся программной инженерии верификация ПО значилась как «доказательство правильности». Хотя концепция была теоретически перспективной, на практике она требовала много времени и была недостаточно всеобъемлющей. Было решено, что доказательство правильности — неэффективный метод тестирования программного обеспечения. Однако, в некоторых случаях демонстрация правильной работы используется и в наши дни, например, приёмо-сдаточные испытания. Во второй половине 1970-х тестирование представлялось как выполнение программы с намерением найти ошибки, а не доказать, что она работает. Успешный тест — это тест, который обнаруживает ранее неизвестные проблемы. Данный подход прямо противоположен предыдущему. Указанные два определения представляют собой «парадокс тестирования», в основе которого лежат два противоположных утверждения: с одной стороны, тестирование позволяет убедиться, что продукт работает хорошо, а с другой — выявляет ошибки в программах, показывая, что продукт не работает. Вторая цель тестирования является более продуктивной с точки зрения улучшения качества, так как не позволяет игнорировать недостатки программного обеспечения.

В 1980-е годы тестирование расширилось таким понятием, как предупреждение дефектов. Проектирование тестов — наиболее эффективный из известных методов предупреждения ошибок. В это же время стали высказываться мысли, что необходима методология тестирования, в частности, что тестирование должно включать проверки на всем протяжении цикла разработки, и это должен быть управляемый процесс. В ходе тестирования надо проверить не только собранную программу, но и требования, код, архитектуру, сами тесты. «Традиционное» тестирование, существовавшее до начала 1980-х, относилось только к скомпилированной, готовой системе (сейчас это обычно называется системное тестирование), но в дальнейшем тестировщики стали вовлекаться во все аспекты жизненного цикла разработки. Это позволяло раньше находить проблемы в требованиях и архитектуре и тем самым сокращать сроки и бюджет разработки. В середине 1980-х появились первые инструменты для автоматизированного тестирования. Предполагалось, что компьютер сможет выполнить больше тестов, чем человек, и сделает это более надёжно. Поначалу эти инструменты были крайне простыми и не имели возможности написания сценариев на скриптовых языках.

В начале 1990-х годов в понятие «тестирование» стали включать планирование, проектирование, создание, поддержку и выполнение тестов и тестовых окружений, и это означало переход от тестирования к обеспечению качества, охватывающего весь цикл разработки программного обеспечения. В это время начинают появляться различные программные инструменты для поддержки процесса тестирования: более продвинутые среды для автоматизации с возможностью создания скриптов и генерации отчетов, системы управления тестами, ПО для проведения нагрузочного тестирования. В середине 1990-х годов с развитием Интернета и разработкой большого количества веб-приложений особую популярность стало получать «гибкое тестирование» (по аналогии с гибкими методологиями программирования).

<h2>Тестовые данные</h2>
<table>

<tr>
<th>Требование</th>
<th>Пароль</th>
<th>Результат</th>
</tr>


<tr>
<td>Количество символов от 8 до 20</td>
<td>qwer$r</td>
<td>False</td>
</tr>
 
<tr>
<td></td>
<td>QW1ertyas$</td>
<td>True</td>
</tr>

<tr>
<td></td>
<td>QWERR$$ASDFG$$ZXCVB%%YHNBGTRFV</td>
<td>False</td>
</tr>

<tr>
<td>Наличие цифр</td>
<td>ujmyhnip123A$</td>
<td>True</td>
</tr>

<tr>
<td></td>
<td>rfvedcsdfD()</td>
<td>False</td>
</tr>

<tr>
<td>Наличие спецсимволов</td>
<td>ae#!@zxdsD3#</td>
<td>True</td>
</tr>

<tr>
<td></td>
<td>asdfghjkl</td>
<td>False</td>
</tr>

<tr>
<td>Наличие прописных букв</td>
<td>LKJHgfds1$</td>
<td>True</td>
</tr>

<tr>
<td>lkjhgfdf</td>
<td>lkjhgfdf</td>
<td>False</td>
</tr>

<tr>
<td>Наличие строчных букв</td>
<td>QWERasdf5%</td>
<td>True</td>
</tr>

<tr>
<td></td>
<td>QWERTGFD</td>
<td>False</td>
</tr>

</table>

<h2>Скриншот выполнения</h2>

![image](https://user-images.githubusercontent.com/90152615/176997570-01054fcb-8677-4fb2-b2f6-702e3cadf400.png)


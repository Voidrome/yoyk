1 Билет
История определения тестирования. Что под ним понимали в разное время?
Первые программные системы разрабатывались в рамках программ научных исследований или программ для нужд министерств обороны. Тестирование таких продуктов проводилось строго формализованно с записью всех тестовых процедур, тестовых данных, полученных результатов. Тестирование выделялось в отдельный процесс, который начинался после завершения кодирования, но при этом, как правило, выполнялось тем же персоналом.
В 1960-х много внимания уделялось «исчерпывающему» тестированию, которое должно проводиться с использованием всех путей в коде или всех возможных входных данных. Было отмечено, что в этих условиях полное тестирование программного обеспечения невозможно, потому что, во-первых, количество возможных входных данных очень велико, во-вторых, существует множество путей, в-третьих, сложно найти проблемы в архитектуре и спецификациях. По этим причинам «исчерпывающее» тестирование было отклонено и признано теоретически невозможным.

В начале 1970-х годов тестирование программного обеспечения обозначалось как «процесс, направленный на демонстрацию корректности продукта» или как «деятельность по подтверждению правильности работы программного обеспечения». В зарождавшейся программной инженерии верификация ПО значилась как «доказательство правильности». Хотя концепция была теоретически перспективной, на практике она требовала много времени и была недостаточно всеобъемлющей. Было решено, что доказательство правильности — неэффективный метод тестирования программного обеспечения. Однако, в некоторых случаях демонстрация правильной работы используется и в наши дни, например, приёмо-сдаточные испытания. Во второй половине 1970-х тестирование представлялось как выполнение программы с намерением найти ошибки, а не доказать, что она работает. Успешный тест — это тест, который обнаруживает ранее неизвестные проблемы. Данный подход прямо противоположен предыдущему. Указанные два определения представляют собой «парадокс тестирования», в основе которого лежат два противоположных утверждения: с одной стороны, тестирование позволяет убедиться, что продукт работает хорошо, а с другой — выявляет ошибки в программах, показывая, что продукт не работает. Вторая цель тестирования является более продуктивной с точки зрения улучшения качества, так как не позволяет игнорировать недостатки программного обеспечения.

В 1980-е годы тестирование расширилось таким понятием, как предупреждение дефектов. Проектирование тестов — наиболее эффективный из известных методов предупреждения ошибок. В это же время стали высказываться мысли, что необходима методология тестирования, в частности, что тестирование должно включать проверки на всем протяжении цикла разработки, и это должен быть управляемый процесс. В ходе тестирования надо проверить не только собранную программу, но и требования, код, архитектуру, сами тесты. «Традиционное» тестирование, существовавшее до начала 1980-х, относилось только к скомпилированной, готовой системе (сейчас это обычно называется системное тестирование), но в дальнейшем тестировщики стали вовлекаться во все аспекты жизненного цикла разработки. Это позволяло раньше находить проблемы в требованиях и архитектуре и тем самым сокращать сроки и бюджет разработки. В середине 1980-х появились первые инструменты для автоматизированного тестирования. Предполагалось, что компьютер сможет выполнить больше тестов, чем человек, и сделает это более надёжно. Поначалу эти инструменты были крайне простыми и не имели возможности написания сценариев на скриптовых языках.

В начале 1990-х годов в понятие «тестирование» стали включать планирование, проектирование, создание, поддержку и выполнение тестов и тестовых окружений, и это означало переход от тестирования к обеспечению качества, охватывающего весь цикл разработки программного обеспечения. В это время начинают появляться различные программные инструменты для поддержки процесса тестирования: более продвинутые среды для автоматизации с возможностью создания скриптов и генерации отчетов, системы управления тестами, ПО для проведения нагрузочного тестирования. В середине 1990-х годов с развитием Интернета и разработкой большого количества веб-приложений особую популярность стало получать «гибкое тестирование» (по аналогии с гибкими методологиями программирования).


2 Билет
В информатике тестирование играет важную роль, поскольку оно помогает обеспечить качество программного обеспечения и его корректную работу. Вот некоторые основные цели тестирования в информатике:

1. Проверка функциональности: Тестирование используется для проверки того, что программа выполняет свои функции в соответствии с требованиями и ожиданиями пользователей.

2. Выявление ошибок: Целью тестирования является обнаружение ошибок (дефектов) в программном обеспечении, таких как ошибки в логике программы, неправильные результаты или некорректное поведение.

3. Улучшение качества: Тестирование помогает повысить качество программного обеспечения путем выявления и исправления ошибок до их попадания к конечным пользователям.

4. Проверка безопасности: Тестирование безопасности используется для выявления уязвимостей в программном обеспечении, которые могут быть использованы злоумышленниками для атак.

5. Проверка производительности: Тестирование производительности оценивает, насколько хорошо программа работает при различных нагрузках и объемах данных.

6. Проверка совместимости: Тестирование совместимости проверяет работоспособность программного обеспечения на различных платформах, устройствах и с разными версиями операционных систем.

7. Уверенность в работоспособности: Целью тестирования является дать уверенность разработчикам, заказчикам и пользователям в том, что программа работает правильно и без сбоев.

8. Экономия времени и ресурсов: Путем тестирования можно выявить проблемы на ранних стадиях разработки, что позволяет избежать более серьезных проблем в будущем и экономит ресурсы.

Это лишь несколько из множества целей тестирования в информатике. Комбинация различных видов тестирования помогает обеспечить качество программного обеспечения и удовлетворение потребностей пользователей.


3 Билет
Объект тестирования включает в себя все элементы, которые подлежат проверке и оценке в процессе тестирования. Обычно объектом тестирования является программное обеспечение, но также могут быть протестированы и другие аспекты, такие как документация, интеграция систем, процессы и т.д.

Базис тестирования определяет основные элементы, на которых строятся тесты. В данном случае, "рабочие продукты" могут быть использованы в качестве базиса тестирования, что означает, что тестирование будет проводиться на основе уже существующих рабочих продуктов или их частей. Это может включать в себя уже разработанные модули, компоненты, функции или другие элементы программного обеспечения, которые будут использоваться для создания и выполнения тестов.

Таким образом, в контексте тестирования "базис тестирования: рабочие продукты" указывает на то, что тестирование будет проводиться на основе уже существующих элементов программного обеспечения или его компонентов.


4 Билет
Дефект, ошибка и отказ — это термины, которые часто используются в контексте тестирования программного обеспечения:

1. Дефект: Дефект (или баг) — это недочет или несоответствие в программном обеспечении, которое приводит к некорректному поведению или нежелательным результатам. Дефект возникает в результате ошибок в процессе разработки или дизайна программы.

2. Ошибка: Ошибка — это конкретное действие или мысль, которое приводит к возникновению дефекта. Ошибка может быть допущена разработчиком в процессе написания кода или тестировщиком при выполнении тестов.

3. Отказ: Отказ (или сбой) — это ситуация, когда программа перестает работать корректно из-за дефекта или ошибки. Отказ означает, что программа не выполняет свои функции правильно или вообще перестает работать.

Таким образом, ошибки приводят к дефектам, которые в свою очередь могут вызывать отказы программы. В процессе тестирования целью является выявление и исправление дефектов до того, как они приведут к отказам в работе программы.


5 Билет
В контексте разработки программного обеспечения и управления качеством, верификация и валидация играют важную роль, а также существует понятие обеспечения качества и контроля качества.

1. Верификация: Это процесс подтверждения того, что продукт разработки (например, программное обеспечение) соответствует своим спецификациям и требованиям. Верификация проверяет, был ли продукт правильно разработан.

2. Валидация: Это процесс подтверждения, что продукт разработки соответствует потребностям и ожиданиям заказчика. Валидация проверяет, был ли разработан правильный продукт.

3. Контроль качества: Это набор процедур, методов и инструментов, направленных на обеспечение качества продукта. Контроль качества включает в себя проверку продукта на соответствие стандартам качества.

4. Обеспечение качества: Это процесс создания и применения всех необходимых процедур, стандартов и руководящих документов для обеспечения того, что продукт будет соответствовать требованиям качества. Обеспечение качества охватывает всю жизненный цикл продукта, начиная с планирования и заканчивая сопровождением.

Все эти понятия направлены на создание продукта высокого качества, соответствующего требованиям заказчика и стандартам отрасли.


6 Билет
Процесс тестирования демонстрирует наличие дефектов, а не их отсутствие
Полное (исчерпывающее) тестирование — невозможно
Раннее тестирование поможет оптимизировать ресурсы на проекте
Необходимость в кластеризации (группировке) дефектов
Пестицидный парадокс связан с тестированием ПО
Полное отсутствие ошибок — заблуждение
Тестирование зависит от контекста. Универсальной стратегии тестирования не существует  
Подробнее о 7 принципах тестирования
 
1. Полное тестирование невозможно

Именно так. Полное тестирование — невозможно. Вместо этого необходим оптимальный объём тестирования, основанный на анализе рисков приложения, веб-сайта, системы и другого ПО. Но как же определить эти риски? Чтобы ответить на вопрос, давайте выполним небольшое упражнение: на ваш взгляд, какая операция с наибольшей вероятностью приведёт к сбою операционной системы? 

Наверняка большинство людей ответит: «Одновременный запуск 15 различных программ». Таким образом, если бы вы тестировали эту операционную систему, то поняли бы, что ошибки, скорее всего, будут заключаться в многозадачности и их необходимо тщательно протестировать.

Ещё один пример из жизни: есть экран, можно ввести два числа, и на экране отобразится сумма чисел. Проверка этого экрана на отображение всех возможных чисел заняла бы бесконечно много времени. Если даже такой простой экран практически невозможно протестировать полностью, что уж говорить о полноценном приложении?

Попытка провести исчерпывающее тестирование приведёт к потере времени и денег компании. Правильный путь — оптимизировать общее количество тестовых случаев, применяя различные стратегии тестирования.

2. Кластеризация (группировка) найденных ошибок
 
Кластеризация (группировка) дефектов утверждает, что небольшое число модулей содержит большую часть всех дефектов. Этот принцип — пример теории 80:20 (также называемого принципом Парето): 80% всех дефектов связаны всего с 20% кода. 

Это основано на исследовании, что 80% пользователей используют лишь 20% программного продукта. Но именно эти 20% ПО содержат наибольшее количество серьёзных дефектов. Этот принцип может помочь вашей команде сосредоточиться на приоритетной области, наиболее востребованной части ИТ-решения.

Однако у такого подхода есть свои недостатки. Если повторять одни и те же тесты и тестировать одни и те же модули снова и снова, то в итоге одинаковые тестовые сценарии перестанут находить новые ошибки.
 
3. Парадокс пестицидов  

Многократное применение одних и тех же пестицидов для выведения насекомых в сельском хозяйстве со временем приводит к выработке у насекомых устойчивости к веществу, что делает его неэффективным в борьбе с насекомыми. Это же применимо и к процессу тестирования ПО. 

Если проводить один и тот же набор повторяющихся тестов, то метод окажется бесполезным для обнаружения новых дефектов. Чтобы не столкнуться с этой проблемой, необходимо регулярно пересматривать и обновлять тестовые примеры, добавляя те, что смогут найти больше дефектов в софте.

Например, рассмотрим программу, которая позволяет распределять ресурсы для выполнения задач с учётом времени, часовых поясов и праздников. Тестировщики написали десять тестовых примеров, связанных с планированием, и после четырёх циклов тестирования все тестовые примеры были пройдены.

Означает ли это, что модуль не содержит дефектов? Скорее всего, нет, поскольку для устранения десяти ошибок потребовалось четыре цикла. Необходимо переосмыслить и написать больше тестовых примеров, особенно если это важная часть приложения.

QA-инженеры не должны просто полагаться на существующие модели тестирования. Лучше постоянно искать пути совершенствования существующих методов, чтобы сделать процесс обеспечения качества более плодотворным. Но даже после длительной работы по тестированию нельзя утверждать, что ИТ-продукт не содержит ошибок. 
 
4. Тестирование демонстрирует наличие дефектов
 
Тестирование подтверждает наличие дефектов, а не их отсутствие, т.е. тестирование снижает вероятность того, что в решении останутся необнаруженные ошибки, но даже если дефекты не найдены, это не является 100% доказательством корректной работы ПО.

Поэтому если ваш QA-отдел сообщает о 100% отсутствии дефектов после проведения цикла тестирования, это не означает, что в ПО их нет. Это означает, что ошибки могут быть, но QA-инженеры их не нашли. Причин необнаружения дефектов может быть много, включая самую распространённую — тестовые примеры не охватывают всех возможных сценариев.

Но что, если вы упорно трудитесь, принимаете все меры по улучшению качества ПО и создаёте на 99% бездефектное решение. А программное обеспечение всё равно не удовлетворяет потребностям и запросам клиентов после релиза. Это подводит к следующему принципу.
 
5. Полное отсутствие ошибок — это заблуждение
 
Бывает, что ИТ-продукт на 99% без ошибок, но всё же непригоден для использования и не удовлетворяет пользователей. Это может произойти в том случае, если система тестируется правильно, но не по тем требованиям.

Тестирование — это не просто поиск дефектов, но и анализ того, что решение удовлетворяет ключевым потребностям бизнеса. Отсутствие ошибок — это заблуждение, т.е. поиск и устранение дефектов не поможет, если созданная система не подходит для применения, не отвечает потребностям бизнеса и требованиям пользователей.

Для решения этой проблемы необходимо применить ещё один принцип —  раннее тестирование ПО.  

6. Раннее тестирование

Как показывает практика, то, что стоит 100 рублей для исправления на этапе проектирования, может стоить 1500 рублей на этапе тестирования и 10 000 рублей, если проблемы будут обнаружены в производственной среде.

Тестирование должно быть интегрировано как можно раньше в жизненный цикл разработки программного обеспечения. Это позволяет обнаружить любые дефекты, возникшие на этапе формирования требований или проектирования на ранних стадиях.

Исправление дефектов силами разработчиков на ранних стадиях тестирования обходится компаниям гораздо дешевле. Но насколько рано следует начинать тестирование? Рекомендуется начинать поиск ошибки с момента формирования требований на проекте. 
 
7. Тестирование зависит от контекста

В тестировании IT-решений не существует единой стратегии, подходящей для всех решений. Например, стратегия тестирования сайта онлайн-кинотеатра будет отличаться от тестирования готового банковского приложения. 

Например, рассмотрим две компании, выпускающие набор из 10 батареек. Первая выпускает наборы премиум-класса по 1000 рублей, а вторая — по 100 рублей, то есть в 10 раз дешевле. Как вы считаете, имеет ли смысл обеим компаниям выстраивать одинаковым процессы контроля качества? Конечно, нет. Первая компания платит больше за качество и, следовательно, у неё более жёсткие стандарты и контроль качества.

Все ИТ-решения разные. В зависимости от типа можно использовать различные подходы, методологии и виды тестирования. Как и в жизни, тестирование любой платёжной системы продуктового магазина в корни будет отличаться от тестирования банкомата или системы видеонаблюдения.



7 Билет

Разработка через тестирование (англ. test-driven development, TDD) — техника разработки программного обеспечения, которая основывается на повторении очень коротких циклов разработки: сначала пишется тест, покрывающий желаемое изменение, затем пишется код, который позволит пройти тест, и под конец проводится рефакторинг нового кода к соответствующим стандартам. Кент Бек, считающийся изобретателем этой техники, утверждал в 2003 году, что разработка через тестирование поощряет простой дизайн и внушает уверенность (англ. inspires confidence)[1].

В 1999 году при своём появлении разработка через тестирование была тесно связана с концепцией «сначала тест» (англ. test-first), применяемой в экстремальном программировании[2], однако позже выделилась как независимая методология.[3].

Тест — это процедура, которая позволяет либо подтвердить, либо опровергнуть работоспособность кода. Когда программист проверяет работоспособность разработанного им кода, он выполняет тестирование вручную.


8 билет

Жизненный цикл программного обеспечения (Software Development Life Cycle, SDLC) представляет собой последовательность этапов или фаз, через которые проходит программное обеспечение, начиная с момента его создания и заканчивая выводом из эксплуатации. Вот общие этапы жизненного цикла ПО:

1. Планирование: На этом этапе определяются требования к программному продукту, составляется план разработки, оцениваются риски и устанавливаются цели проекта.

2. Анализ: Происходит сбор и анализ требований к программному продукту. Определяются функциональные и нефункциональные требования.

3. Проектирование: Создается архитектура программного продукта, определяются структура и компоненты системы, планируется интерфейс и взаимодействие между ними.

4. Разработка: На этом этапе программное обеспечение фактически создается с учетом предыдущих этапов. Программисты пишут код, тестируют его и интегрируют в общую систему.

5. Тестирование: Проводятся различные виды тестирования, чтобы убедиться в правильности работы программного продукта и соответствии его требованиям.

6. Внедрение: Программное обеспечение устанавливается и запускается в рабочем окружении. Пользователи могут начать использовать продукт.

7. Эксплуатация и поддержка: После внедрения продукта в эксплуатацию поддерживается его работоспособность, выпускаются исправления ошибок и обновления.

8. Снятие с эксплуатации: В конце жизненного цикла программного обеспечения оно может быть выведено из эксплуатации из-за устаревания, изменения бизнес-требований или других причин.

Жизненный цикл программного обеспечения помогает структурировать процесс разработки ПО, управлять рисками и обеспечить качество конечного продукта.


9 билет

Каскадная модель разработки программного обеспечения — это классический подход к управлению жизненным циклом разработки, который предполагает последовательное выполнение этапов разработки в строго определенном порядке. Основные этапы каскадной модели обычно включают в себя:

1. Определение требований (Requirements): На этом этапе определяются и документируются требования к программному продукту.
   
2. Анализ (Analysis): Происходит анализ требований, чтобы определить, какие функции и возможности должны быть реализованы.

3. Проектирование (Design): Разрабатывается архитектура программного продукта на основе выявленных требований.

4. Реализация (Implementation): На этом этапе кодируются и тестируются компоненты программы.

5. Тестирование (Testing): Проводятся тесты для проверки работоспособности и соответствия программы требованиям.

6. Внедрение (Deployment): После успешного завершения всех предыдущих этапов программное обеспечение внедряется в рабочую среду.

7. Сопровождение (Maintenance): Проводится поддержка и обновление программного продукта после его внедрения.

Каждый этап зависит от успешного завершения предыдущего этапа, и изменения на поздних стадиях могут быть затруднительными и дорогостоящими.


10 билет

Итеративная модель – модель, в которой работы выполняются параллельно с непрерывным анализом полученных результатов и корректировкой последующих этапов работы. Она основана на цикле Деминга: Планируй – Реализуй – Проверяй – Оценивай. Порядок стадий разработки: Начальное планирование Разработка, которая выполняется циклически: Планирование Написание требований Архитектура / дизайн Реализация Тестирование Оценка Запуск и поддержка.
найдено на beqa.pro
Инкрементальная модель. Инкрементальная модель — это модель разработки программного обеспечения, в которой программное обеспечение анализируется, проектируется, разрабатывается и тестируется постепенно (каждый раз добавляется немного больше), пока оно не будет завершено. Процесс разработки программного обеспечения заканчивается, когда продукт соответствует всем требованиям.

11 билет

Спира́льная модель, предложенная Барри Боэмом в 1986 году, стала существенным прорывом в понимании природы разработки ПО. Она представляет собой процесс разработки программного обеспечения, сочетающий в себе как итеративность, так и этапность.

Отличительной особенностью этой модели является специальное внимание рискам, влияющим на организацию жизненного цикла. Боэм формулирует десять наиболее распространённых (по приоритетам) рисков:

Дефицит специалистов.
Нереалистичные сроки и бюджет.
Реализация несоответствующей функциональности.
Разработка неправильного пользовательского интерфейса.
«Золотая сервировка», перфекционизм, ненужная оптимизация и оттачивание деталей.
Непрекращающийся поток изменений.
Нехватка информации о внешних компонентах, определяющих окружение системы или вовлечённых в интеграцию.
Недостатки в работах, выполняемых внешними (по отношению к проекту) ресурсами.
Недостаточная производительность получаемой системы.
Разрыв между квалификацией специалистов и требованиями проекта[1]
Большая часть этих рисков связана с организационными и процессными аспектами взаимодействия специалистов в проектной команде.

Каждый виток спирали соответствует созданию фрагмента или версии программного обеспечения, на нём уточняются цели и характеристики проекта, определяется его качество и планируются работы следующего витка спирали. Таким образом углубляются и последовательно конкретизируются детали проекта и в результате выбирается обоснованный вариант, который доводится до реализации. Каждый виток разбит на 4 сектора:

определение целей,
оценка и разрешение рисков,
разработка и тестирование,
планирование следующей итерации.
На каждом витке спирали могут применяться разные модели процесса разработки ПО. В конечном итоге на выходе получается готовый продукт.

Разработка итерациями отражает объективно существующий спиральный цикл создания системы. Неполное завершение работ на каждом этапе позволяет переходить на следующий этап, не дожидаясь полного завершения работы на текущем. При итеративном способе разработки недостающую работу можно будет выполнить на следующей итерации.

Главная задача — как можно быстрее показать пользователям системы работоспособный продукт, тем самым активизируя процесс уточнения и дополнения требований. Основная проблема спирального цикла — определение момента перехода на следующий этап. Для её решения необходимо ввести временные ограничения на каждый из этапов жизненного цикла. Переход осуществляется в соответствии с планом, даже если не вся запланированная работа закончена. План составляется на основе статистических данных, полученных в предыдущих проектах, и личного опыта разработчиков

12 билет

Есть четыре уровня программного тестирования:
модульное тестирование — проводится в самом начале, это проверка отдельных кусочков кода;
интеграционное тестирование — проверка связей между готовыми элементами, а также сочетаемости программы с окружающей средой (оборудованием и ОС);
системное тестирование — проверяет, соответствует ли программа заявленным характеристикам;
приемочное тестирование — согласование продукта с клиентом.

13 билет

Уровни тестирования программного обеспечения могут различаться в зависимости от методологии разработки и специфики проекта, но обычно выделяют следующие основные уровни тестирования:

1. Модульное тестирование (Unit Testing): На этом уровне проводятся тесты отдельных модулей или компонентов программы для проверки их корректности работы в изоляции от других частей системы.

2. Интеграционное тестирование (Integration Testing): Проверяется взаимодействие между различными модулями или компонентами программы для обнаружения ошибок в их совместной работе.

3. Системное тестирование (System Testing): На этом уровне тестируется вся система в целом, чтобы убедиться, что она соответствует требованиям и работает правильно в реальных условиях.

4. Приемочное тестирование (Acceptance Testing): Тестирование, проводимое заказчиком или конечными пользователями, чтобы убедиться, что программа полностью соответствует их ожиданиям и требованиям.

5. Функциональное тестирование (Functional Testing): Проверка функциональности программы с точки зрения соответствия её спецификациям и требованиям.

6. Нагрузочное тестирование (Load Testing): Исследование поведения системы при различных уровнях нагрузки для определения её производительности и стабильности.

7. Совместимостное тестирование (Compatibility Testing): Проверка работы программы на различных платформах, операционных системах, браузерах и т.д.

Это основные уровни тестирования, которые помогают обеспечить качество программного продукта перед его выпуском в эксплуатацию.

14 билет

Зачем нужны компонентные тесты?

Ведь есть, скажем, юнит-тесты, которые подробно тестируют потроха компонентов. Они досконально проверяют, что компонент работает в соответствии с замыслом разработчика. Но часто это проверка "пуговиц", а не того, как сидит костюм в целом. И не всегда поведение, задуманное программистом, совпадает с тем что хотел заказчик.


А еще есть, например, приемочные тесты. И они устраняют все указанные недостатки. Но, к сожалению, вносят новые. Они медленные, часто нестабильные, и обычно ручные. При этом они только свидетельствуют о проблеме, но не локализуют ее.


Очевидно, что напрашивается необходимость промежуточных тестов, которые станут золотой серединой между тестами модульными и приемочными. Этой серединой могут стать компонентные тесты.


Что такое компонентные тесты?

Это тесты на публичный API компонента. Соответственно, они пишутся на том же языке, что и компонент. Задача тестов:


проверить соответствие компонента своим контрактам
проверить следование требованиям
Последнее особенно важно, т.к. юнит-тесты обычно пишутся исходя из ожиданий разработчика, а здесь необходимо проверить ожидания клиентов.

Очевидно, что компонентные тесты имеют смысл, когда у вас есть выделенные компоненты с обширным интерфейсом. Например, динамическая библиотека или COM-объект. Тогда компонентные тесты дадут максимальный эффект.


Плюсы к-тестов:

Придают стабильность разработке. Очевидно, что всесторонняя проверка публичных интерфейсов позволяет содержать компонент в более-менее работоспособном виде.
Точно локализуют проблемы. Даже если сам компонентный тест достаточно общий, его всегда можно отладить вглубь, быстро добравшись до боевого кода. При этом тестовое окружение будет минимальным и автоматически настроенным.
Ускоряют разработку при критичном кол-ве разработчиков. Известно, что программисты — они как лошади. Если одна лошадь тянет повозку с мощностью 1 л. с., то восемь лошадей тянут с мощностью всего лишь около 4 л. с. Так и добавление еще одного разработчика в команду (особенно в конце проекта) часто не только не ускоряет, но и замедляет его. Тогда как добавление разработчика компонентных тестов всегда идет в плюс, поскольку он действует относительно независимо от команды: делает (по сути внешние) тесты, ускоряет сборку билда, оптимизирует сборочные файлы etc.
Проясняют (а затем проверяют) требования заказчика. Поскольку разработчик компонентных тестов не завязан на реализацию, он меньше подвержен эффекту "я сам знаю как надо". В случае неоднозначного требования обычный разработчик склонен делать как удобнее (интереснее, быстрее, легче). Тогда как кт-разработчик в этом случае склонен уточнять, что именно ожидается заказчиком.
Относительно стабильные и относительно быстрые (в сравнении с ручными тестами и автоматизированными тестами через пользовательский интерфейс).

Минусы к-тестов:

Время на разработку и поддержку. Очевидно, что альфа-версия продукта, если часть времени потрачена на написание компонентных тестов, появится позднее. Будет ли выигрыш в целом? Выйдет ли релиз раньше? Это хороший вопрос. Мое мнение: при разработке с компонентными тестами релиз выйдет примерно в те же сроки. Но — с меньшими авралами и более предсказуемо по срокам. Время разработки закономерно увеличится, время багфикса и стабилизации сократится. Поскольку вторая часть значительно менее предсказуема, ее сокращение благотворно повлияет на количество переработок и нервотрепки. Однако это только мой опыт, а реальность может оказаться иной. Вполне возможно что время, выделенное на компонентные тесты, окажется бездарно потрачено на дублирование существующих юнит-тестов.
Меньшая взаимозаменяемость. Разделение ролей повышает эффективность, но снижает взаимозаменяемость. Разработчики редко горят желанием лезть вглубь компонентных тестов, которые могут иметь (или имитировать) достаточно сложное окружение. Разработчики компонентных тестов далеко не так хорошо знают боевой код, чтобы с легкостью его править.
Раздражающее дублирование. При хороших юнит-тестах, компонентные тесты часто оказываются по большей части избыточными. Это и раздражает, и ставит под сомнение их необходимость. Согласование планов на юнит и компонентное тестирование помогает, но полностью устранить дублирование обычно не удается.
Необходимость следовать правильному workflow. При получении требований задача должна ставиться одновременно на разработчика и разработчика тестов. Тогда они заканчивают работу примерно одновременно. Компонент прогоняется через тесты, ошибки оперативно ловятся и правятся, и на выход уходит более-менее готовый продукт. В этом случае выгода от компонентных тестов максимальна. Но часто бывает, что сроки давно профуканы, все брошены писать только код, и компонент отправляют в ручное тестирование без тестов. А уже потом приглашают разработчика тестов — мол нехорошо, что код без тестов выпущен, надо бы их дописать. В этом случае большинство багов находится ручными тестировщиками, разработчики делают исправления вслепую (либо сами тестируют правки руками), а написанные постфактум тесты находят лишь незначительное количество ошибок (что отрицательно влияет на мораль их писателя). Такое использование компонентных тестов в лучшем случае бесполезно, а застраховаться от этого тяжело.
Мало подходящих людей. Разработчик компонентных тестов должен, с одной стороны, уметь писать код на языке компонента (а это, например, C++). Причем, если окружение для запуска компонента обширное, код может быть достаточно сложный. А с другой стороны, уметь скрупулезно тестировать чужую работу. Таких людей не очень много, и они идут обычно сразу в разработчики. Но все-таки такие люди есть, и о них — следующая часть.

15 билет

Шаблон Arrange-Act-Assert (AAA) — это популярный подход к написанию тестовых методов в юнит-тестировании, который помогает структурировать тесты для лучшей читаемости и понимания. Вот что означают каждая из этих частей:

1. **Arrange (Подготовка):** В этой части теста происходит подготовка к самому тестированию. Здесь создаются все необходимые объекты, настраиваются параметры, инициализируются переменные и прочие действия, которые необходимы для выполнения самого теста.

2. **Act (Действие):** Этот этап представляет собой непосредственное выполнение действия или метода, который требуется протестировать. Здесь вызывается тестируемый метод или проводится необходимая операция.

3. **Assert (Проверка):** В этой части происходит проверка результата выполнения действия на соответствие ожидаемому результату. Здесь устанавливаются утверждения (assertions), которые проверяют правильность работы кода и определяют, прошел ли тест успешно или нет.

16 билет

Тестирование интеграции компонентов — это процесс проверки корректности взаимодействия между различными компонентами или модулями программного обеспечения. Целью такого тестирования является обнаружение ошибок, возникающих при интеграции компонентов, и проверка правильности передачи данных и вызова функций между ними.

### Объекты тестирования:
- Компоненты: Каждый отдельный компонент, который должен быть интегрирован.
- Интерфейсы: Методы и способы взаимодействия между компонентами.
- Потоки данных: Проверка передачи данных между компонентами.
- Обработка ошибок: Проверка обработки ошибок при интеграции.

### Базис тестирования:
- Спецификация: Требования к компонентам и их взаимодействию.
- Дизайн системы: Структура системы и способы интеграции компонентов.
- Тестовые сценарии: Планы тестирования, описывающие взаимодействие компонентов.

### Критерии входа:
- Готовность компонентов: Убедиться, что все компоненты готовы к интеграции.
- Спецификация интерфейсов: Убедиться, что интерфейсы компонентов соответствуют спецификации.
- Тестовые данные: Подготовить необходимые тестовые данные для интеграционного тестирования.

### Критерии выхода:
- Успешное взаимодействие: Все компоненты успешно интегрированы и работают корректно.
- Отсутствие ошибок: Ошибки при интеграции минимизированы или исправлены.
- Соответствие требованиям: Интегрированная система соответствует требованиям и спецификации.

### Измерения и метрики:
- Количество ошибок: Количество обнаруженных ошибок при интеграции.
- Время интеграции: Время, затраченное на успешную интеграцию компонентов.
- Покрытие кода: Степень покрытия кода интеграционными тестами.
- Степень автоматизации: Доля автоматизированных тестов в процессе интеграционного тестирования.

Тестирование интеграции компонентов играет важную роль в обеспечении качества программного обеспечения и позволяет выявить проблемы, которые могут возникнуть при слиянии различных частей системы.

17 билет

то такое системное тестирование? 
Системное тестирование - это этап тестирования программного обеспечения, на котором тестируется полный и полностью интегрированный программный продукт на основе спецификации программного обеспечения (SRS: Software Requirement Specification). Основная цель такого тестирования — это процесс оценки, который охватывает аспекты, связанные с бизнесом, функциональной спецификой и потребительскими ожиданиями. 

Это один из видов тестирования "черного ящика", выполняемый для оценки соответствия всей системы заданным требованиям, и он полностью основан на точке зрения пользователя. Для этого типа тестирования предполагается отсутствие необходимости в глубоком понимании внутренней структуры, дизайна или кода приложения. 

Это тестирование должно проводиться после завершения системного интеграционного тестирования, когда были проверены функциональные и нефункциональные требования. 

При интеграционном тестировании тестировщики сосредоточены на поиске ошибок/дефектов в интегрированных модулях. В то время как при системном тестировании тестировщики сосредоточены на поиске ошибок/дефектов, основанных на поведении программного приложения, дизайне программного обеспечения и ожиданиях конечного пользователя. 

Почему важно системное тестирование? Почему так важно проводить системное тестирование?  
В жизненном цикле ПО (SDLC) системное тестирование выполняется в качестве первого уровня тестирования.  

На этом этапе тестирования проверяется, соответствует ли система функциональным требованиям или нет.  

Системное тестирование позволяет проверить архитектуру приложения и бизнес-требования.  

Приложение/система тестируется в среде, близкой к проектируемой производственной среде.  

Как правило, системным тестированием занимается отдельная команда. Кроме того, системное тестирование проводится на стэйджинговом или клонированном экземпляре рабочего сервера, что подразумевает тестирование программного приложения в условиях, максимально приближенных к реальной производственной среде. 

18 билет

Приемочное тестирование (Acceptance Testing) — это вид тестирования, направленный на проверку соответствия разрабатываемого продукта конечным пользователям или заказчику. Цель приемочного тестирования заключается в том, чтобы удостовериться, что продукт соответствует ожиданиям заказчика и требованиям бизнеса.

### Объекты тестирования:
- Функциональные требования: Проверка соответствия функциональности продукта требованиям заказчика.
- Нефункциональные требования: Проверка производительности, безопасности, удобства использования и других аспектов.
- Интерфейсы: Проверка взаимодействия продукта с другими системами или компонентами.
- Данные: Проверка корректности обработки данных приложением.

### Базис тестирования:
- Требования к продукту: Спецификация требований от заказчика.
- Сценарии использования: Описание типичных сценариев использования продукта.
- Документация: Руководства пользователя, спецификации и другие документы.

### Критерии входа:
- Готовность продукта: Убедиться, что продукт готов для тестирования.
- Согласование с заказчиком: Получить подтверждение от заказчика о готовности к приемочному тестированию.
- Тестовые данные: Подготовить необходимые данные для проведения тестирования.

### Критерии выхода:
- Успешное завершение тестирования: Продукт прошел приемочное тестирование без критических ошибок.
- Удовлетворенность заказчика: Заказчик удовлетворен результатами тестирования и готов принять продукт.
- Документация: Завершенные отчеты о результатах приемочного тестирования.

### Измерения и метрики:
- Количество обнаруженных дефектов: Количество ошибок, найденных во время приемочного тестирования.
- Время прохождения тестирования: Время, затраченное на проведение приемочного тестирования.
- Уровень удовлетворенности заказчика: Оценка заказчика по результатам приемочного тестирования.
- Покрытие требований: Степень покрытия функциональных и нефункциональных требований тестами.

Приемочное тестирование играет ключевую роль в обеспечении качества продукта и удостоверении, что он соответствует потребностям и ожиданиям заказчика перед его выпуском на рынок.

19 билет

Статическое тестирование — тип тестирования, который предполагает, что программный код во время тестирования не будет выполняться. При этом тестирование может быть как ручным, так и автоматизированным. Статическое тестирование начинается на ранних этапах жизненного цикла ПО и является частью процесса верификации.

Динамическое тестирование — тип тестирования, который предполагает запуск программного кода. Таким образом анализируется поведение программы во время ее работы. Для выполнения динамического тестирования необходимо, чтобы тестируемый программный код был написан, скомпилирован и запущен. При этом может выполняться проверка внешних параметров работы программы: загрузка процессора, использование памяти, время отклика и т.д. Динамическое тестирование является частью процесса валидации программного обеспечения.

20 билет

Тестирование производительности — это вид тестирования программного обеспечения, направленный на определение его способности работать с определёнными рабочими нагрузками и в определённых условиях.

Основные цели тестирования производительности:

выявление проблем, связанных с быстродействием, надёжностью и стабильностью системы;

определение возможных узких мест и точек отказа.

Виды тестирования производительности:

Нагрузочное тестирование. Проверка системы на работоспособность под определённой нагрузкой.

Стресс-тестирование. Определение предельных рабочих условий системы, при которых она продолжает функционировать, но с ограничениями по производительности.

Тестирование стабильности. Проверка системы на способность работать без сбоев и с заданной производительностью на протяжении длительного времени.

Тестирование масштабируемости. Определение способности системы адекватно функционировать при увеличении рабочих нагрузок или количества пользователей.

21 билет

Жизненный цикл дефекта (Defect Life Cycle) — это последовательность этапов, через которые проходит дефект, начиная с его обнаружения и заканчивая исправлением и проверкой. Этот процесс обычно управляется системой управления дефектами (Defect Tracking System) в рамках тестирования программного обеспечения. Вот типичные этапы жизненного цикла дефекта:

1. Зарегистрирован (New): Дефект был обнаружен и зарегистрирован в системе управления дефектами.

2. В работе (Assigned): Дефект назначен ответственному разработчику или тестировщику для дальнейшего анализа и исправления.

3. В процессе исправления (In Progress): Разработчик работает над исправлением дефекта.

4. Исправлен (Fixed): Дефект исправлен разработчиком.

5. На проверке (Ready for Retest): Исправленный дефект передается на повторное тестирование.

6. Проверен (Retest): Дефект проверен тестировщиком после исправления.

7. Подтвержден (Closed/Verified): Дефект подтвержден как исправленный и закрыт.

Отчет о дефекте содержит информацию о каждом этапе жизненного цикла дефекта, включая описание проблемы, шаги для воспроизведения, приоритет, статус исправления и другие детали. Он помогает команде разработки и тестирования отслеживать прогресс по устранению дефектов и обеспечивает прозрачность в процессе работы над качеством продукта.

Хороший отчет о дефекте должен быть информативным, точным и содержать достаточно данных для того, чтобы разработчики могли легко понять проблему и приступить к ее исправлению.


22 билет

Классификация дефектов по различным критериям может помочь в управлении процессом тестирования и улучшении качества программного обеспечения. Вот несколько распространенных способов классификации дефектов:

1. По приоритету:
   - Высокий приоритет (High Priority): Дефекты, которые могут серьезно повлиять на функциональность продукта или препятствовать его использованию.
   - Средний приоритет (Medium Priority): Дефекты, которые не являются критическими, но все же требуют исправления.
   - Низкий приоритет (Low Priority): Дефекты, которые имеют незначительное влияние на продукт и могут быть исправлены позже.

2. По серьезности:
   - Критический (Critical): Дефекты, которые приводят к сбоям системы или серьезным ошибкам в работе программы.
   - Мажорный (Major): Дефекты, которые могут вызвать проблемы, но не блокируют работу продукта.
   - Минорный (Minor): Незначительные дефекты, которые не влияют на работоспособность продукта, но могут быть улучшены.

3. По типу дефекта:
   - Функциональные дефекты: Связанные с некорректной работой функциональности продукта.
   - Интерфейсные дефекты: Связанные с проблемами в пользовательском интерфейсе.
   - Производительностные дефекты: Связанные с производительностью или эффективностью продукта.
   - Безопасностные дефекты: Связанные с уязвимостями безопасности продукта.

4. По области, в которой был обнаружен дефект:
   - Дефекты в функциональности: Связанные с работой конкретной функции или модуля.
   - Дефекты в данных: Связанные с проблемами ввода/вывода данных.
   - Дефекты в производительности: Связанные с производительностью системы.

Это лишь несколько примеров классификации дефектов. Выбор критериев классификации зависит от конкретных потребностей команды разработки и тестирования. Классификация дефектов помогает эффективно управлять процессом исправления и повышать качество разрабатываемого продукта.

23 билет

Тестовый сценарий — это описание последовательности действий для проверки общей работоспособности и функциональности приложения или сайта.

Это стратегическое руководство для выявления критических для работы системы ошибок. Тестировщики составляют эту инструкцию на базе «пути пользователя» и ситуаций, возникающих в ходе взаимодействия конечного клиента с приложением.

Основные элементы тестового сценария:

стартовые условия;

входные данные;

ожидаемые действия пользователя;

ожидаемые результаты.

Тестовый сценарий позволяет протестировать работу любой функции приложения.

24 билет

Обязанности тестировщика включают:

Изучение документации по продукту, инструкций и рекомендаций от разработчиков и продуктовых аналитиков.

Составление тест-кейсов для тестирования.

Проведение тестирования.

Сбор и анализ полученных результатов: ошибок, сбоев, некорректной работы, уязвимостей.

Оформление полученных результатов в виде отчёта с рекомендациями для разработчиков.

Также тестировщик должен обладать следующими навыками:

знание основ HTML и одного из языков программирования;

навыки работы с MS Office для документирования результатов;

навыки написания автотестов (Selenium, PHPUnit);

умение работать с Bug-трекерами;

знание SQL.